var log = require("log"); log.setLevel("info");
var CryptoJS = require("../util/hmac-sha256.js").CryptoJS;
var base64 = require("../util/base64");
var busConfig = require("../servicebus/config");
var document = require("document");

const DEFAULT_EXP = 3600;
const DEFAULT_KEY_NAME = "SendListen";

/*
 * signature-string = SHA-256('https://<yournamespace>.servicebus.windows.net/'+'\n'+ 1438205742)
 * SharedAccessSignature sig=<signature-string>&se=<expiry>&skn=<keyName>&sr=<URL-encoded-resourceURI>
 * @function generateSignature
 * @param {Object} params: expected parameters
 * @param {Numeric} expiry in seconds e.g. 1438205742 (date in seconds). Optional, defaults to DEFAULT_EXP
 * @param {String} keyName: hask key name (actually the name of the policy). Optional, defaults to /azure/servicebus/config.policy
 * @param {String} key: the secret key to use to generate the hash. Defaults to /azure/servicebus/config.hashKey
 * @param {String} resource: the targeted resource on the service, e.g.https://<yournamespace>.servicebus.windows.net/testqueue
 */

function TokenGenerator(){
}

TokenGenerator.prototype.generateSignature = function (params) {  

    if (!params || !params.resource) {

        throw {

            errorCode: "Missing_Parameter",
            errorDetail: "azure/authentication.generateSignature: you need to provide a resource"
        };
    }

    var expiry = params.expiry;
    if (!expiry) {

        expiry = Math.round(new Date().getTime() / 1000) + DEFAULT_EXP;
        log.warn("azure/authentication.generateSignature: no expiry defined, setting it to default value " +  DEFAULT_EXP);
    }

    var keyName = params.keyName; 
    if (!keyName) {

        keyName = busConfig.policy;
        log.warn("azure/authentication.generateSignature: no keyName defined, setting it to default (config) value " +  keyName);
    }

    var key = params.key; 
    if (!key) {

        key = busConfig.hashKey;
        log.warn("azure/authentication.generateSignature: no key defined, setting it to default (config) value");
    }    

    var signatureString = encodeURIComponent(params.resource) + '\n' + expiry; 
    var hash = this._getHash(key, signatureString);
    var sharedSignature = "sig=" + encodeURIComponent(hash) + "&se=" + expiry + "&skn=" + keyName + "&sr=" + encodeURIComponent(params.resource);
    return sharedSignature;
};

TokenGenerator.prototype._getHash = function(key, signatureString) {

    var hash = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key).update(signatureString).finalize()
    return base64.stringify(hash)
};

TokenGenerator.prototype.loadToken = function(params){

    var queryObj = {

        query: 'type = "token" and resource = "' + params.resource +  '"',
        fields: "*"
    };

    var resp = document.query(queryObj);
    if (resp.metadata.status == "failure") {
        log.error("Failed to load tokens \n " + JSON.stringify(resp));
        throw resp;
    }

    if (resp.result.documents.length == 0){
        var token = this.generateSignature(params);
        log.warn("generating a new token for " + params.resource);
        var docParam = {
            type: "token",
            token: token,
            resource: params.resource
        };

        var resp = document.save(docParam);
        if (resp.metadata.status == "failure") {
            log.error("Failed to save token \n " + JSON.stringify(resp) + "\n " + JSON.stringify(docParam));
        }
        return token;
    }
    console.log(JSON.stringify(resp));
    return resp.result.documents[0].token;
}
